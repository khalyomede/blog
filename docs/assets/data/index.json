{"hash":"3e98125a0a4072cde816a521b2aa372d32911504","data":{"allPost":{"edges":[{"node":{"id":"1380ad413815b2f42c5366bd324e0123","path":"/post/quick-home-made-fuzzy-search/","title":"Quick home made fuzzy search","excerpt":"No time to implement a fuzzy search library? Me too.","published_at":"2020-10-20 22:24:00","content":"\r\nLot of occasion presented to me where I have two choice: either take this package, learn, install, implement, check for advanced usage, and ultimately spend some time just for a small fuzzy search dependent component (like a home page search), or just roll my own.\r\n\r\nLet's be honest, fuzzy search is one of these algorithm that you are tempted to think:\r\n\r\n> That's just an SQL like query!\r\n\r\nIt is, or at least it can be in its easiest form possible. Let me show you. These examples will feature Laravel because I know this framework well.\r\n\r\n## Level 1: basic search\r\n\r\nTake the search term, and perform a like in SQL. Simple, working, no complexity. Ideal for simple things.\r\n\r\n```php\r\n// app/Http/Controllers/SearchController.php\r\nnamespace App\\Http\\Controllers;\r\n\r\nuse App\\Http\\Controllers\\Controller;\r\nuse App\\Http\\Requests\\SearchRequest;\r\nuse App\\Post;\r\nuse Illuminate\\View\\View;\r\n\r\nclass SearchController extends Controller\r\n{\r\n\tpublic function search(SearchRequest $request): View\r\n\t{\r\n\t\t$term = $request->term;\r\n\t\t$posts = Post::where(\"title\", \"like\", \"%$term%\")\r\n\t\t\t->orWhere(\"excerpt\", \"like\", \"%$term%\")\r\n\t\t\t->orWhere(\"content\", \"like\", \"%$term%\")\r\n\t\t\t->get();\r\n\r\n\t\treturn view(\"search\")->with(\"posts\", $posts);\r\n\t}\r\n}\r\n```\r\n\r\n## Level 2: VSCode Command Palette search-like\r\n\r\nIf you are on VSCode on Sublim Text, you might use this trick where you write this:\r\n\r\n```\r\naphtcontsea\r\n```\r\n\r\nWhich is the concatenation of app-http-controller-search, and VSCode is correctly finding your file `Controllers/SearchController.php`.\r\n\r\nThis is because the search algorithm is actually splitting each characters, and include a wildcard placeholder to say \"between each of the characters of the search, you might found anything, nevermind, match it.\r\n\r\nThis means you don't even have to write these \"/\", because the regular expression is expecting them.\r\n\r\nCheck it by yourself on this [regex101.com](https://regex101.com/r/ydPJcj/1) example.\r\n\r\nHere is a suggested implementation:\r\n\r\n```php\r\n// app/Http/Controllers/SearchController.php\r\nnamespace App\\Http\\Controllers;\r\n\r\nuse App\\Http\\Controllers\\Controller;\r\nuse App\\Http\\Requests\\SearchRequest;\r\nuse App\\Post;\r\nuse Illuminate\\View\\View;\r\n\r\nclass SearchController extends Controller\r\n{\r\n\tpublic function search(SearchRequest $request): View\r\n\t{\r\n\t\t$characters = str_split($request->term);\r\n\r\n\t\t$search = array_map(function(string $character): string {\r\n\t\t\treturn \"%$character%\";\r\n\t\t}, $characters);\r\n\r\n\t\t$posts = Post::where(\"title\", \"like\", $search)\r\n\t\t\t->orWhere(\"excerpt\", \"like\", $search)\r\n\t\t\t->orWhere(\"content\", \"like\", $search)\r\n\t\t\t->get();\r\n\r\n\t\treturn view(\"search\")->with(\"posts\", $posts);\r\n\t}\r\n}\r\n```\r\n\r\nWhich would return the following inside `$search` if you type `blog`:\r\n\r\n```\r\n%b%%l%%o%%g%\r\n```\r\n\r\nExtra `%` are not a problem, just redundant. With a few little effort, we have made something good enough.\r\n\r\n## When using fuzzy search\r\n\r\nWhat we did is closer to primitive search than real fuzzy search.\r\n\r\nFuzzy search works by mutating the search term until it find similarities with an existing word, like trying to removing some characters until finding an existing word.\r\n\r\nThis have the advantage of finding near match, something that we can't find with the examples above. If you made a typo to `blog`, like `bkog`, it will no longer match, when fuzzy search would. Try changing a letter in the [regexp101.com](https://regex101.com/r/ydPJcj/1) example to see it in action.\r\n\r\nOther advantage, fuzzy search provides a result confidence ratio for each results, so you can order search results by this new variable (which we can't do with the examples above).\r\n\r\nImplementing fuzzy search involves a lot of time finding the best approach, so this should come as an upgrade of an existing simple search algorithm.\r\n\r\nI would not advise to start with fuzzy search because this is also a cost depending how it is implemented (you might have to first convert every of your potental results to fit the library, which is something you would not have to do with pure SQL).\r\n"}},{"node":{"id":"9eb5594ecc8d7e1ccded5321dcbf383d","path":"/post/decoupled-programing/","title":"Decoupled programing","excerpt":"A paradigm that augment flexibility and performance.","published_at":"2020-10-20 20:49:00","content":"\r\nFrameworks are legion today. At such point that if you don't learn some, you might get evinced from the game.\r\n\r\nI am guilty of knowing [Laravel](https://laravel.com/), [Vue](https://laravel.com/) and [Bootstrap](https://getbootstrap.com/). These are still my go to tools at my job.\r\n\r\nOne day I watched [this video](https://www.youtube.com/watch?v=nmD1Q4FsXCc) about Rasmus speaking of his vision for PHP, a brief of the history of the language, and some of his thoughts.\r\n\r\nI remember of one particular sentence in his talk:\r\n\r\n> Today, frameworks ship too much. We should not have the database engine booted up for a static page. We should control what we want at a certain moment.\r\n\r\nI tried to find a way to work with decoupled components. At first it was an experiment, and then, I found I could go on with a functional router, then a view engine (Blade), then an ORM (Eloquent), etc...\r\n\r\n## The idea\r\n\r\nThe concept is to create packages that are not aware of the outside world. This has several advantages:\r\n\r\n-   You can pull the package anywhere, since you follow the setup code\r\n-   The complexity is reduced because I consider dependency injection userland\r\n-   The footprint is **way** much lower because I used functional programing first to delivery the easiest developer experience\r\n\r\nThe core concept of these ready-to-pull packages is to solve one core issue the fastest possible.\r\n\r\nFor example, if you use [folded/translation](https://github.com/folded/translation), you only have to tell the library where your translations are stored:\r\n\r\n```php\r\nuse function Folded\\setTranslationFolderPath;\r\nuse function Folded\\setDefaultTranslationLang;\r\n\r\nsetTranslationFolderPath(\"path/to/langs\");\r\nsetDefaultTranslationLang(\"en\");\r\n```\r\n\r\nThat's all. Now you can use the library anywhere:\r\n\r\n```php\r\nuse function Folded\\setTranslationLang;\r\nuse function Folded\\getTranslation;\r\n\r\nsetTranslationLang(\"fr\");\r\ngetTranslation(\"Welcome to my blog\"); // \"Bienvenue sur mon blog\"\r\n```\r\n\r\nIf you noticed, I have to use the namespace \"Folded\". This is what makes the app light, because the code will only require these functions instead of loading a whole class for example.\r\n\r\n## Results on a real app\r\n\r\nI have built an app (that I currently do not know if I will release or no), which is about teaching about nature and science by displaying a feed of news and facts.\r\n\r\nUsing only decoupled packages (and aproximatively 80% of mine), I managed to use a maximum of 0.7 Mb of memory (and a serber latency of about 7-20 ms on an AWS free tier t2.micro server running Ubuntu 20).\r\n\r\nFor comparison, Laravel (no negatives critics intended) loads the hello world page with a memory peak usage of about 12 Mb. It's something that I expected since you got a whole lot of features, including Pipes, Validation, Eloquent and events, Queing, ... out of the box, and activated.\r\n\r\nIf I ever wanted to try to trim the maximum out of Laravel to keep on this example, I would have to dig in the provider file, and comment the services I don't use.\r\n\r\nWhile this does the job, whenever you deactivate a service that you then want to use, you got to remember you commented it so you need to constantly keep track of this anytime you decide to use a new facade or so.\r\n\r\nThis is something you would never have to think of with decoupled programing since you are conscious of what you pull because you actually had to use `composer install` yourself. This offers the benefit of being more \"aware\" of what you got on your code base, and forces you to document yourself on what you use.\r\n\r\nWithout speaking on the fact that you are free to use whatever package you need, which is something you would not totally be able to do with frameworks that have made some choices (like using Blade for Laravel, that would make no sense to use anything else).\r\n\r\n## The downsides\r\n\r\nThe main downside is the time you need to spend to document yourself to implement a new library to your web app. This is something that most of the time have been solved if you use a framewokr (queue management, ORM, logging, ...).\r\n\r\nThe other downside is the organisational part. Using a framework is a huge insurance for big companies since the framework is opniated on the way to organise views, models, commands, ... This downside can be a showstopper if you fear or do not have the right knowledge to organize correctly (which means the maintenance is tough).\r\n\r\nBut I have seen framework with bad code habits and wrong code organisation too, so this is something to debate. One can imagine setting a de-facto code structure and iterating on this even using decoupled programing (the proof is the people that use a `app/Model` folder, when Laravel natively put them in `app` folder, something that will change in version 8).\r\n\r\n## Conclusions\r\n\r\nA really fun experiment, that I think I will keep maturing and eventually propose for review to see if people show interest over this concept.\r\n\r\nI feel in my opinion it is something quite related to functional programing, and this need to come back to the root of the algorithm itself, coming back to more simplicity.\r\n\r\nSo in the end, I think that it is another tool for a specific set of problems to solve. Not some fancy new way to develop web apps.\r\n"}}]}},"context":{}}